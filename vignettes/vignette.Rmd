---
title: "Definition of binding sites from iCLIP signal"
author:
- name: Mirko Brüggemann
  affiliation: Buchmann Institute for Molecular Life Sciences (BMLS), Frankfurt Germany
- name: Kathi Zarnack
  affiliation: Buchmann Institute for Molecular Life Sciences (BMLS), Frankfurt Germany
output:
  BiocStyle::html_document:
    toc_float: true
package: BindingSiteFinder
abstract: |
    Precise knowledge on the binding sites of an RNA-binding protein (RBP) is key to understand (post-) transcriptional regulatory processes. The package BindingSiteFinder provides all functionalities to define exact binding sites defined from iCLIP data. The following vignette describes the complete workflow. 
vignette: |
    %\VignetteIndexEntry{Definition of binding sites from iCLIP signal}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, error = FALSE, warning = TRUE)
```	

```{r, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({
    library(GenomicRanges)
    library(GenomicAlignments)
    library(rtracklayer)
    library(ggplot2)
    library(tidyr)
    library(ComplexHeatmap)
    library(BindingSiteFinder)
    library(forcats)
    library(dplyr)
})
```

# Preface

## Motivation

Most cellular processes are regulated by RNA-binding proteins (RBPs). Knowledge on their exact positioning can be obtained from individual-nucleotide resolution UV crosslinking and immunoprecipitation (iCLIP) experiments. In a recent publication we described a complete analysis workflow to detect RBP binding sites from iCLIP data. The workflow covers all essential steps from quality control of sequencing reads, different peak calling options, to the downstream analysis and definition of binding sites. The pre-processing and peak calling steps rely on publicly available software, whereas the definition of the final binding sites follows a custom procedure implemented in BindingSiteFinder. This vignette explains how equally sized binding sites can be defined from a genome-wide iCLIP coverage.


## Prerequisites

The workflow described herein is based on our recently published complete iCLIP analysis pipeline [@busch2020]. Thus, we expect the user to have preprocessed their iCLIP sequencing reads up to the point of the peak calling step. In brief, this includes basic processing of the sequencing reads, such as quality filtering, barcode handling, mapping and the generation of a single nucleotide crosslink file for all replicates under consideration. As we describe in our manuscript, replicate .bam files may or may not be merged prior to peak calling, for which we suggest PureCLIP [@Krakau2017]. For simplicity, we address only the case in which peak calling was performed on the merge of all replicates.

![**Overview of the preprocessing workflow**. ](images/preprocessing.png){#preprocessing}

## Installation

The `r Biocpkg("BindingSiteFinder")` package is available at [https://bioconductor.org](https://bioconductor.org) and can be installed via `BiocManager::install`:

```{r BiocManager, eval=FALSE}
if (!require("BiocManager"))
    install.packages("BiocManager")
BiocManager::install("BindingSiteFinder")
```

**Note:** If you use BindingSiteFinder in published research, please cite:

> Busch, A., Brüggemann, M., Ebersberger, S., & Zarnack, K. (2020) iCLIP data analysis: A complete pipeline from sequencing reads to RBP binding sites. *Methods*, 178, 49-62. <https://doi.org/10.1016/j.ymeth.2019.11.008>




# Quick start

Here we show the most basic steps for the binding site definition. Depending on the RBP and the iCLIP data at hand a variety of options can be set and modified, which we will discuss in the sections below. The following code chunk assumes that the iCLIP data is present in the form of a `BSFDataSet` object (For details see [Construction of the BindingSiteFinder dataset](## Construction of the BindingSiteFinder dataset)). Further we assume that orthogonal gene annotation is present as `GRanges` for the genes and as `GRangesList` for the transcript regions (For details see [Construct the annotation objects](## Construct the annotation objects)). 

The `BSFind()` function now estimates the optimal binding site width and filter settings from the data. The output is stored in `bdsQuick` which can be used to produce diagnostic and result plots for each step. Finally resulting binding sites can be exported as BED files using `exportToBED()`.

```{r, echo=TRUE, eval=FALSE}
# load iCLIP data and gene annotation files
files <- system.file("extdata", package="BindingSiteFinder")
load(list.files(files, pattern = ".rda$", full.names = TRUE))
load(list.files(files, pattern = ".rds$", full.names = TRUE)[1])
load(list.files(files, pattern = ".rds$", full.names = TRUE)[2])
# run BSFind to compute binding sites
bdsQuick = BSFind(object = bds, anno.genes = gns, anno.transcriptRegionList = regions, est.subsetChromosome = "chr22")
# export output as .bed
exportToBED(bdsQuick, con = "./myBindingSites.bed")
```


# Standard workflow

## Construction of the BindingSiteFinder dataset

The following example is based on four replicates of the RNA-binding protein U2AF65. Reads (as .bam files) from all four replicates were merged and subjected to *PureCLIP* for peak calling.

As input, the `BindingSiteFinder` package expects two types of data. First, a `GRanges` object of all ranges that should be merged into binding sites. In our example, this was the created by *PureCLIP* and we just have to import the file. The second information are the individual crosslinks as .BigWig files, to which the path has to be provided. Together with additional meta information about our samples we created a meta table in form of a `data.frame`. 

```{r}
# load crosslink sites
csFile <- system.file("extdata", "PureCLIP_crosslink_sites_examples.bed", 
                      package="BindingSiteFinder")
cs = import(con = csFile, format = "BED", extraCols=c("additionalScores" = "character"))
cs$additionalScores = NULL
# Load clip signal files and define meta data object
files <- system.file("extdata", package="BindingSiteFinder")
clipFilesP <- list.files(files, pattern = "plus.bw$", full.names = TRUE)
clipFilesM <- list.files(files, pattern = "minus.bw$", full.names = TRUE)
# make the meta table
meta = data.frame(
  id = c(1:4),
  condition = factor(rep("WT", 4)), 
  clPlus = clipFilesP, clMinus = clipFilesM)
meta
```

This `data.frame` has to have at minimum three columns, which must be named `condition`, `clPlus` and `clMinus`. The `condition` column specifies the different conditions of the replicates (see [Work with different conditions](## Work with different conditions) for more examples). The `clPlus` and `clMinus` columns point towards the strand-specific coverage for each replicate. This information will be imported as `Rle objects` upon object initialization. The number of ranges and crosslinks imported in the object can be shown once it has been constructed[^1].

[^1]: Here, we load a previously compiled `BindingSiteFinder DataSet` to save disc space.

```{r, eval=FALSE}
library(BindingSiteFinder)
bds = BSFDataSetFromBigWig(ranges = cs, meta = meta, silent = TRUE)
```

```{r, eval=TRUE, echo=FALSE}
exampleFile <- list.files(files, pattern = ".rda$", full.names = TRUE)
load(exampleFile)
meta = data.frame(
  id = c(1:4),
  condition = factor(rep("WT", 4)), 
  clPlus = clipFilesP, clMinus = clipFilesM)
bds@meta = meta
names(bds@signal$signalPlus) = c("1_WT", "2_WT", "3_WT", "4_WT")
names(bds@signal$signalMinus) = c("1_WT", "2_WT", "3_WT", "4_WT")
```

```{r, eval=FALSE}
exampleFile <- list.files(files, pattern = ".rda$", full.names = TRUE)
load(exampleFile)
bds
```


## Construct the annotation objects

### Create annotation for genes

As gene annotation, any desired source can be used. Here, we use [GENCODE](https://www.gencodegenes.org/) gene annotations (hg38) from chromosome 22 imported from GFF3 format as an example[^6]. First, we make use of the [GenomicFeatures](https://bioconductor.org/packages/release/bioc/html/GenomicFeatures.html) package and import our annotation as a `TxDB` database object. This database can be queried using the `genes()` function to retrieve the positions of all genes from our resource as `GRanges` objects. 

[^6]: Note that we again only load a previously compiled object to save disc space.

```{r, echo=TRUE, eval=FALSE}
library(GenomicFeatures)
# Make annotation database from gff3 file
annoFile = "./gencode_v37_annotation.gff3"
annoDb = makeTxDbFromGFF(file = annoFile, format = "gff3")
annoInfo = import(annoFile, format = "gff3")
# Get genes as GRanges
gns = genes(annoDb)
idx = match(gns$gene_id, annoInfo$gene_id)
elementMetadata(gns) = cbind(elementMetadata(gns),
                             elementMetadata(annoInfo)[idx,])
```

```{r}
# Load GRanges with genes
geneFile <- list.files(files, pattern = "gns.rds$", full.names = TRUE)
load(geneFile)
gns
```

### Create annotation for transcript regions

Transcript regions can be extracted from the same `TxDb` resource that we created beforehand. We store the ranges of each region we are interested as an element of a `GRangestList` and name the elements accordingly.

```{r, eval=FALSE}
# Count the overlaps of each binding site for each region of the transcript. 
cdseq = cds(annoDb) 
intrns = unlist(intronsByTranscript(annoDb)) 
utrs3 = unlist(threeUTRsByTranscript(annoDb)) 
utrs5 = unlist(fiveUTRsByTranscript(annoDb)) 
regions = list(CDS = cdseq, Intron = intrns, UTR3 = utrs3, UTR5 = utrs5)
```

```{r}
# Load list with transcript regions
regionFile <- list.files(files, pattern = "regions.rds$", full.names = TRUE)
load(regionFile)
```


## Run BSFind()

Once the `BSFDataSet` object is created and all annotations are loaded `BSFind()` can be called without setting any other option[^3]. This will cause all individual proccessing functions to be executed as indicated by the output. 

[^3]Note: Here we set `est.subsetChromosom` because we have only signal on chromosome 22 to save disc space

```{r}
bds1 = BSFind(object = bds, anno.genes = gns, anno.transcriptRegionList = regions,
              est.subsetChromosome = "chr22", est.geneResolution = "coarse")
```

It is good practice to once visualize the entire binding site definition process after `BSFind()` was executed.

```{r, fig.retina = 1, dpi = 100}
processingStepsFlowChart(bds1)
```

As a default all of the shown steps are executed sequentially in the given order. To change that order each function can be called individually to set up a custamized workflow (for details see[]()). In order to evaluate the performance of each processing step a number of diagnostic plots are pre-implemented.

### Pre-filtering of crosslink sites

An optional step prior to the actual merging of crosslink sites into binding sites is pre-filtering. Depending on the experiment type or sequencing depth, it might be useful to retain only the most informative crosslink sites. In the case of *PureCLIP*, the positions called as significantly enriched (hereafter called *PureCLIP sites*) are associated with a binding affinity strength score (hereafter called *PureCLIP score*) which can be used as a metric for the pre-filtering step. As default PureCLIP sites with the lowest 1% score will be removed. 

```{r, fig.retina = 1, dpi = 100}
pureClipGlobalFilterPlot(bds1)
```

### Esitmate the optimal binding site width

In case the option `bsSize` is not set, the optimal binding site width is estimated from the data directly (using the `estimateBsWidth` function). Since the final binding site width depends on the quality of the input crosslink sites, `bsSize` is estimated together with the gene-wise filter level (`cutoff.geneWiseFilter`). That is filtering by the top X% crosslink sites per gene. Filtering on gene level has been shown to be really effective in diluting the most informative signal from the data. 

Here the diagnostic show the ratio between the crosslink events within binding sites and the crosslink events in adjacent windows to the binding sites. The higher the ratio, the better the associated binding site width captures the distribution of the underlying crosslink events. The plot shows how that ratio behaves for different binding site width under variing levels of the gene-wise filter. 

```{r, fig.retina = 1, dpi = 100}
estimateBsWidthPlot(bds1)
```

Parameter values are estimated on a single chromosome (`est.bsResolution`) on varying levels of accuracy. For `est.geneResolution` options "coarse" results in 20% steps, "medium" in 10%, "fine" in 5% and "finest" in 1% steps. For `est.bsResolution` option "coarse" and "medium" approximate binding sites by extending the center of the each merged crosslink region. In "coarse" the center is found by the maximum PureCLIP score, in "medium" the center is found by the position with the most stacked crosslinks. Option "fine" employs a full binding site definition cycle. Binding sites are tested from the minimum size, which is 3, up to `maxBsWidth`. 

After iterating over all sets given the above resolutions a mean score per binding site width is calculated and the binding site width that yielded the highest score is selected as optimal. The `est.minimumStepGain` option allows control over the minimum additional gain in the score that a tested width has to have to be selected as the best option (the default is 2% increase). This is particularly useful when the estimated mean score flattens out at a certain point showing only a very small increase in the score per binding site width increase. Samples with broad binding RBPs or samples with poor coverage tend to show this behavior. 


### Filter crosslink sites per gene

The binding site quality can be increased by using only a subset per gene of all PureCLIP sites for the binding site defintion. This is because the strength of a binding site is tied to the expression level of the hosting gene. Thus a gene-wise percentage filter will increase the quality on all hosting genes in the same order. This cutoff can either be estimated (using `estimateBsWidth()`) or can directly be set as an input (`cutoff.geneWiseFilter()`). The respective detail function for this task is `pureClipGeneWiseFilter()`, which can also be called seperatly.

```{r, fig.retina = 1, dpi = 100}
duplicatedSitesPlot(bds1)
```

Since PureCLIP sites can overlap with multiple different genes given by the degree of overlap in the annotation, a diagnostic function helps to visualize the magnitude. To handle overlaps the `overlaps` parameter can be used with options "keepSingle", "removeAll" and "keepAll".


### Merge crosslink sites into binding sites

Here we turn the single-nucleotide wide PureCLIP sites into binding sites of a desired width. This width can either be set directly using the `bsSize` parameter or it can be estimated from the data directly using `estimateBsSize()` (for details see [Esitmate the optimal binding site width](### Esitmate the optimal binding site width). 

In detail the `makeBindingSites()` function is called, which performs an iterative resizing of all crosslink sites. This is based on further parameters that guide the positioning of the final binding site. A summary of these options and filters is shown in the following plot.

```{r, fig.retina = 1, dpi = 100}
makeBsSummaryPlot(bds1)
```

In addition to the parameters above, the `minWidth` option can be of particular interest for the experienced user. This option defines that all ranges smaller than `minWidth` are removed during the merging routine. It helps to remove mapping artifacts that cause large pile-ups of crosslinks on a single position without any other signal in their surrounding. The number and width of the fitted regions in each iteration round is visualized in the following plot[^7].

[7] Note that due to the sparsity of the example data this plot will look different with a real data-set

```{r, fig.retina = 1, dpi = 100}
mergeCrosslinkDiagnosticsPlot(bds1)
```


### Assessing replicate reproducibility 

Since the initial *PureCLIP* run was based on the merged signal of all four replicates, an additional reproducibility filter must be used. More specifically, we ask which of the computed binding sites are reproduced by the individual replicates. Since replicates might differ in library size, a replicate-specific threshold is computed base on the binding site support distribution. That is how many crosslinks fall into the compute binding site for each replicate. 

This distribution is visualized for each replicate alongside and the respective threshold in the plot below. Since we did not specify an explicit threshold when calling `BSFind()` the 5% quantile with a lower boundary of 1 crosslink is used as default. Here a binding site would be called reproducible by eg. replicate 2 if at least 4 crosslinks from that replicate fall into the range of the binding site. 

```{r, fig.retina = 1, dpi = 100}
reproducibilityFilterPlot(bds1)
```

Next, the computed replicate-specific thresholds are applied and the number of replicate the must meet the threshold can be specified. This offers another level of filtering and allows for some adjustment, since not always all replicates are forced to agree on every binding site. For instance, we could implement the rule that 3 out of 4 replicates should agree for a binding site, while setting the quantile cutoff to 5% for all 4 replicates.

The following plot visualizes the degree of agreement among the replicates in their support level. Since we did not specify any of the options ("nReps" and "minCrosslinks") in `BSFind()` the default (N-1) will be used. Here the default results in a binding site beeing called reproducible if 3 out of 4 replicate meet their specific threshold. 

```{r, fig.retina = 1, dpi = 100}
reproducibilitySamplesPlot(bds1)
```


### Target gene identification

Once binding sites have been defined and filtered for reproducibility they are assigned to their target genes by making use of the initially provided annotation (`anno.genes`). Depending on the source and organism, gene annotations overlap each other to some degree. The following plot illustrates this degree in the specific annotation set that we use. As indicated by the plot we use the default strategy `frequency` is used to resolve overlapping cases. This means that whenever a binding site overlaps with multiple genes with a different gene type the type that was most frequently seen in the data is selected as representative[^8][^9].

[^8] Depending on the analysis it could be useful to change this option. Available other options are: "hierarchy", "remove" and "keep"

[^9] Note that if an overlaps exists, but gene types are identical options "frequency" and "hierarchy" will cause the gene that was seen first to be selected as representative. 

```{r, fig.retina = 1, dpi = 100}
geneOverlapsPlot(bds1)
```

Once overlaps are resolved the hosting genes can be counted and grouped by their type and visualized as a bar-chart. 

```{r, fig.retina = 1, dpi = 100}
targetGeneSpectrumPlot(bds1)
```


### Transcript region identification

Similar to the target gene, each binding site can be assigned to a hosting transcript region. This is done using the `anno.transcriptRegionList` resource that we defined earlier. Essentially each binding site is overlapped with each of the ranges given in the region list. As one would expect, the problem of overlapping annotations is increase manifold on the level of transcript regions compared to entire genes. The following plot illustrates this degree for our example data-set. We observe that most overlaps are generated by binding sites that are either within an intron or a 3'UTR. As indicated by the plot we use the default strategy `frequency` is used to resolve these cases. Since introns were most frequently overved in the data, the transcript region "intron" was selected in the cases[^`0].

[^10] Note that again ther are other options available ("hierarchy", "flag" and "remove")

```{r, fig.retina = 1, dpi = 100}
transcriptRegionOverlapsPlot(bds1)
```

Once overlapping cases are monitored the transcript region binding spectrum can be visualized as a bar-chart. 

```{r, fig.retina = 1, dpi = 100}
transcriptRegionSpectrumPlot(bds1)
```


### Re-assign binding site strength

PureCLIP scores, to some degree provide information on binding site strength and here we re-assign them to final binding sites. Since multiple score can be present for a single binding sites the `match.option` argument lets one decide if score should be transfered by the maximum, mean or sum. Here we use the maximum, which is the default. The resulting distribution of strength-scores is visualized in the following density plot[^11].

[^11] Make sure to run this function last when making an own workflow

```{r, fig.retina = 1, dpi = 100}
globalScorePlot(bds1)
```


## Exporting your results

To make the most out of your `BindingSiteFinder` analysis a set of export functions exists that allow a seemless transtion of the results to any further analysis.

### Additional analysis in R/Bioconductor

If one stays inside the R/ Bioconductor environment one can simply extract the final binding sites as `GenomicRanges`, which enables full functionality that comes with this powerful data class. As indicated by the print all information from each processing step is kept in the meta data of the granges object. This makes it easy to combine your analysis results with orthogonal data and projects.

```{r}
getRanges(bds1)
```

### Export as UCSC BED

For visual inspection and integration with further data-sets results can be easily exported in the widely used .bed format. This offers a quick way for manual inspection of the resulting binding sites in tools like IGV or UCSC genome browser.

```{r, eval=FALSE}
exportToBED(bds1, con = "./myResults.bed")
```

### Export genes and feature lists

TBA


# Additional functions

Besides the standard workflow and main processing functions `BindingSiteFinder` offers a variety of other useful functions that come in handy when working with iCLIP data. In the following sections we demonstrate some these functionalities.

## Subset data for faster iterations 

Sub-setting a `BSFinderData` object can be useful in a variety of cases, e.g. for reducing the object size for faster parameter testing, limiting the analysis to some candidate genes etc. Here, we subset the object by a random set of 100 binding sites and plot their count distribution.

```{r, fig.retina = 1, dpi = 100}
set.seed(1234)
bdsSub = bds[sample(seq_along(getRanges(bds)), 100, replace = FALSE)]

cov = coverageOverRanges(bdsSub, returnOptions = "merge_positions_keep_replicates")
df = mcols(cov) %>%
    as.data.frame() %>%
    pivot_longer(everything())

ggplot(df, aes(x = name, y = log2(value+1), fill = name)) +
    geom_violin() +
    geom_boxplot(width = 0.1, fill = "white") +
    scale_fill_brewer(palette = "Greys") +
    theme_bw() +
    theme(legend.position = "none") +
    labs(x = "Samples", y = "#Crosslinks (log2)")
```

## Merge replicate signal 

Depending on the task at hand, one either wants to keep the iCLIP signal separated by replicates or merge the signal over the replicates (e.g. of the same condition). Merging signal can be done using the `collapseReplicates()` function. Doing so allows for example to identify the proportion of crosslink events that each sample contributes to the total of a binding site. Here, we did this for the first 100 binding sites. We sort all binding sites by their fraction and color the plot based on the replicate. 

```{r, fig.retina = 1, dpi = 100}
bdsMerge = collapseReplicates(bds)[1:100]
covTotal = coverageOverRanges(bdsMerge, returnOptions = "merge_positions_keep_replicates")

covRep = coverageOverRanges(bds[1:100], returnOptions = "merge_positions_keep_replicates")

df = cbind.data.frame(mcols(covTotal), mcols(covRep)) %>%
    mutate(rep1 = round(`1_WT`/ WT, digits = 2) * 100,
           rep2 = round(`2_WT`/ WT, digits = 2) * 100,
           rep3 = round(`3_WT`/ WT, digits = 2) * 100,
           rep4 = round(`4_WT`/ WT, digits = 2) * 100) %>%
    tibble::rowid_to_column("BsID") %>%
    dplyr::select(BsID, rep1, rep2, rep3, rep4) %>%
    pivot_longer(-BsID) %>%
    group_by(BsID) %>%
    arrange(desc(value), .by_group = TRUE) %>%
    mutate(name = factor(name, levels = name)) %>%
    group_by(name) %>%
    arrange(desc(value), .by_group = TRUE) %>%
    mutate(BsID = factor(BsID, levels = BsID))


ggplot(df, aes(x = BsID, y = value, fill = name)) +
    geom_col(position = "fill", width = 1) +
    theme_bw() +
    scale_fill_brewer(palette = "Set3") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 7)) +
    labs(x = "Binding site ID",
         y = "Percentage",
         fill = "Replicate"
         ) +
    scale_y_continuous(labels = scales::percent)
```

## Merge replicate signal 

Similar to exporting the binding sites as *BED* file for external visualization, one can do the same with the iCLIP signal itself. We again use the [rtracklayer](https://www.bioconductor.org/packages/release/bioc/html/rtracklayer.html) `export` function. Here, we first export the signal from a single replicate. Next, we first merge the signal over the replicates and export the combined signal. 

```{r, eval=FALSE}
sgn = getSignal(bds)
export(sgn$signalPlus$`1_WT`, con = "./WT_1_plus.bw", format = "bigwig")
export(sgn$signalMinus$`1_WT`, con = "./WT_1_minus.bw", format = "bigwig")
```

```{r, eval=FALSE}
bdsMerge = collapseReplicates(bds)
sgn = getSignal(bdsMerge)
export(sgn$signalPlus$WT, con = "./sgn_plus.bw", format = "bigwig")
export(sgn$signalPlus$WT, con = "./sgn_minus.bw", format = "bigwig")
```



# Diagnostic coverage polots

## Super nice wrapper functions

TBA

## Make diagnostic coverage plots

It can also be useful to examine the coverage on example binding sites. A simple function for this is the `bindingSiteCoveragePlot()`, which plots the coverage as bars in a defined range around a selected binding site. The function is based on the [Gviz](http://bioconductor.org/packages/release/bioc/html/Gviz.html) package. The `plotIdx` indicates which range should be used as center, the `flankPos` parameter allows to zoom in and out. In addition to the selected range, also all other ranges which fall into the selected window will be shown. Here, we plot the coverage of a random binding site from the final object, once per replicate and once merged per condition. 

```{r, fig.retina = 1, dpi = 100}
bindingSiteCoveragePlot(bds1, plotIdx = 8, flankPos = 100, autoscale = TRUE)
bindingSiteCoveragePlot(bds1, plotIdx = 8, flankPos = 100, mergeReplicates = TRUE)
```

A common case that makes use of this function is when one wants to see why a particular binding site is lost after a certain filtering step. Here, we look at a binding site that was filtered out from the final object by the reproducibility filter. Doing so, we can visually confirm that binding sites 5 and 6 were correctly removed by the reproducibility filter function.

```{r, fig.retina = 1, dpi = 100}
rangesBeforeRepFilter = getRanges(bds)
rangesAfterRepFilter = getRanges(bds1)
idx = which(!match(rangesBeforeRepFilter, rangesAfterRepFilter, nomatch = 0) > 0)
rangesRemovedByFilter = rangesBeforeRepFilter[idx]
bdsRemovedRanges = setRanges(bds, rangesRemovedByFilter)

bindingSiteCoveragePlot(bdsRemovedRanges, plotIdx = 2, flankPos = 50)
bindingSiteCoveragePlot(bdsRemovedRanges, plotIdx = 2, flankPos = 50, mergeReplicates = TRUE)
```

We could also look at the final binding site definition and see how they were derived from the initial *PureCLIP sites*. To achieve this, we make use of the `customRange` slot to add these sites at the bottom of the coverage plot.

```{r, fig.retina = 1, dpi = 100}
pSites = getRanges(bds)
bindingSiteCoveragePlot(bds1, plotIdx = 8, flankPos = 20, autoscale = TRUE,
                        customRange = pSites, customRange.name = "pSites", shiftPos = -10)
```

Another use case would be to check the coverage on some example genes, or as we do here on the binding site with the highest number of crosslinks: 

```{r, fig.retina = 1, dpi = 100}
bindingSiteCoverage = coverageOverRanges(bds1, returnOptions = "merge_positions_keep_replicates")
idxMaxCountsBs = which.max(rowSums(as.data.frame(mcols(bindingSiteCoverage))))
bindingSiteCoveragePlot(bds1, plotIdx = idxMaxCountsBs, flankPos = 100, mergeReplicates = FALSE, shiftPos = 50)
```

It is also possible to anchor the plot on any other `GenomicRange`. Here, we take annotated CDS regions and ask for the one with the most overlapping binding sites. We then use this ranges as center for the plot and further zoom in to a particular range. We then make use of the `customRange` slot to re-include the binding site ranges as additional annotation shown underneath the signal. Additionally, one could also add a custom annotation track in the form of a `GenomicRanges` or `TxDB` object. 

```{r, eval=FALSE}
bdsCDS = setRanges(bds1, regions$CDS)
cdsWithMostBs = which.max(countOverlaps(regions$CDS, getRanges(bds1)))

bindingSiteCoveragePlot(bdsCDS, plotIdx = cdsWithMostBs, showCentralRange = FALSE,
                       flankPos = -250, shiftPos = -50, mergeReplicates = TRUE,
                       highlight = FALSE, customRange = getRanges(bds1))
bindingSiteCoveragePlot(bdsCDS, plotIdx = cdsWithMostBs, showCentralRange = FALSE,
                       flankPos = -250, shiftPos = -50, mergeReplicates = TRUE,
                       highlight = FALSE, customRange = getRanges(bds1),
                       customAnnotation = regions$CDS)
```



# Variations of the standard workflow

## Work with different conditions

When dealing with different conditions, one simply adjusts the meta data table in the `BSFDataSet` object. Here, we artificially label two of our four replicates as KD to exemplary show some applications. Be aware that the `condition` column is a factor and that the order of the factor levels matters in downstream functions.

```{r}
# Set artificial KD condition
metaCond = getMeta(bds1)
metaCond$condition = factor(c(rep("WT", 2), rep("KD", 2)), levels = c("WT", "KD"))
bdsCond = setMeta(bds1, metaCond)
# Fix replicate names in signal
namesCond = c("1_WT", "2_WT", "3_KD", "4_KD")
sgn = getSignal(bdsCond)
names(sgn$signalPlus) = namesCond
names(sgn$signalMinus) = namesCond
bdsCond = setSignal(bdsCond, sgn)
```

### Adapted reproducibility filtering

When multiple conditions are present, one can decide if sample reproducibility should be assessed for each condition separately or joint over all samples. This can be controlled by either providing a vector, with length equal to the number of condition, or a single value for the parameters `nReps` and `cutoff` [^13] [^14].

[^13] Note: Be careful when treating conditions differently, as downstream analysis such as differential binding testing is impaired. 
[^14] Note: The order by which the `nReps` and `cutoff` vectors are applied to the samples is defined by the order of the factor levels of the *condition* column in the *meta* data. 

```{r}
bdsRep = pureClipGeneWiseFilter(bdsCond, cutoff = 0.2, anno.genes = gns)
bdsRep = makeBindingSites(bdsRep, bsSize = 7)
bdsRep = reproducibilityFilter(bdsRep)
```

```{r, fig.retina = 1, dpi = 100}
reproducibilityFilterPlot(bdsRep)
```

```{r, fig.retina = 1, dpi = 100}
reproducibilitySamplesPlot(bdsRep)
```

### Changes to the diagnostic coverage plots

The diagnostic example plots that can be made with the `bindingSiteCoveragePlot()` function also support multiple conditions and adjust the coloring accordingly. 

```{r, fig.retina = 1, dpi = 100}
bindingSiteCoverage = coverageOverRanges(bds1, returnOptions = "merge_positions_keep_replicates")
idxMaxCountsBs = which.max(rowSums(as.data.frame(mcols(bindingSiteCoverage))))
bindingSiteCoveragePlot(bdsCond, plotIdx = idxMaxCountsBs, flankPos = 100, mergeReplicates = FALSE, shiftPos = 50)
```


## Work without a gene annotation

In case one does not have an appropriate gene annotation at hand a simplified workflow function can be defined that still allows binding site definition. To achieve this we simply combine all processing functions that do not require an explicit annotation into a new reduced wrapper [^15].

[^15] Note: We highly recommend using an adequate gene annotation since it improves the quality of the analysis dramatically.  

```{r}
customBSFind <- function(object) {
    obj = pureClipGlobalFilter(object)
    obj = makeBindingSites(obj, bsSize = 7)
    obj = reproducibilityFilter(obj)
    obj = annotateWithScore(obj, getRanges(object))
    return(obj)
}
bdsSimple = customBSFind(bds)
```

Since no gene or transcript level assignment was performed, the related diagnostic plots are not available. Yet the diagnostics for the functions we have called in `customBSFind()` can be used to assess the performance of our analysis. 

At first we look at our reduced analysis flow-chart:

```{r, fig.retina = 1, dpi = 100}
processingStepsFlowChart(bdsSimple)
```

Then assess the initial score distribition:

```{r, fig.retina = 1, dpi = 100}
pureClipGlobalFilterPlot(bdsSimple)
```

Look at the binding site generation:

```{r, fig.retina = 1, dpi = 100}
makeBsSummaryPlot(bdsSimple)
```

And assess sample reproducibility:

```{r, fig.retina = 1, dpi = 100}
reproducibilityFilterPlot(bdsSimple)
```



# Session info

```{r}
sessionInfo()
```

# Bibliography 
